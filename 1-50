9. Palindrome Number

```
class Solution {
    public boolean isPalindrome(int x) {
        if (x<0)
            return false;
        int a=x,r=0;
        while (a>0){
            r=r*10+a%10;
            a/=10;
        }
        return r==x;
    }
}

```


36.Valid Sudoku 

```
public class isValidSudoku {
    public boolean isValidSudoku(char[][] board) {
        for (int i=0;i<9;i++){
            Set<Character> row=new HashSet<>();
            Set<Character> col=new HashSet<>();
            Set<Character> cube=new HashSet<>();
            for (int j=0;j<9;j++){
                if (board[i][j]!='.'&&!row.add(board[i][j]))
                    return false;
                if (board[j][i]!='.'&&!col.add(board[j][i]))
                    return false;
                int cubeRow=3*(i/3)+j/3,cubeCol=3*(i%3)+j%3;
                if (board[cubeRow][cubeCol]!='.'&&!cube.add(board[cubeRow][cubeCol]))
                    return false;
            }
        }
        return true;
    }
}
```
思路：不一定要这个数独有解，只要当前已经填充的数字是合法的就可以。
由于只要当前已经填充的数字是合法的就可以，因此只需要判断9*9网格的每一行、每一列、9个小九宫格是否合法。如果在每一行、每一列、每个9个小九宫格内有重复数字则不合法。
第i个九宫格的第j个格点的行号可表示为i/3*3+j/3
第i个九宫格的第j个格点的列号可表示为i%3*3+j%3

39.Combination Sum

```
public class combinationSum {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result=new LinkedList<>();
        List<Integer> temp=new LinkedList<>();
        //首先进行排序，避免重复搜索
        Arrays.sort(candidates);
        combin(candidates,target,0,temp,result);
        //返回列表
        return result;
    }
    private void combin(int[] arrays,int target,int index,List<Integer> temp,List<List<Integer>> result){
        //如果目标和的差值小于0，表示该路径出现错误
        if (target<0){
            return;
        //等于表示，这是一条正确的路径，将其add到result上
        }else if (target==0){
            result.add(new LinkedList<>(temp));
        //否则的话，目标和的差值大于0，继续进行深度优先搜索
        }else {
            //选取之后的每个数字都是一种可能性，其中index的作用是避免搜索之前搜索过的数组元素
            for (int i=index;i<arrays.length;i++){
                temp.add(arrays[i]);
                //先加入元素，然后进行搜索，这里进行DFS搜索，如果不满足，就把temp列表里的元素去除掉
                combin(arrays,target-arrays[i],i,temp,lists);
                temp.remove(temp.size()-1);
            }
        }
    }
}
```
思路：因为我们可以任意组合任意多个数，看其和是否是目标数，而且还要返回所有可能的组合，所以我们必须遍历所有可能性才能求解。为了避免重复遍历，我们搜索的时候只搜索当前或之后的数，而不再搜索前面的数。因为我们先将较小的数计算完，所以到较大的数时我们就不用再考虑有较小的数的情况了。这题是非常基本且典型的深度优先搜索并返回路径的题。本题需要先排序，不然过不了Leetcode。

40.combinationSum2

```
public class combinationSum2 {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> result=new LinkedList<>();
        List<Integer> temp=new LinkedList<>();
        Arrays.sort(candidates);
        combin(candidates,target,0,temp,result);
        return lists;
    }
    private void combin(int[] array,int target,int index,List<Integer> temp,List<List<Integer>> result){
        if (target<0){
            return;
        }else if (target==0){
            list.add(new LinkedList<>(temp));
        }else {
            for (int i=index;i<array.length;i++){
                // 跳过本轮剩余的重复元素
                if(i>index &&array[i]==array[i-1]) continue;
                temp.add(array[i]);
                // 递归时下标加1
                combin(array,target-array[i],i+1,temp,result);
                temp.remove(temp.size()-1);
            }
        }
    }
}
```
思路：这题和I的区别在于同一个数只能取一次，比如数组中只有3个1，那结果中也最多只有3个1，而且结果也不能重复。所以我们在递归时首先要把下标加1，这样下轮搜索中就排除了自己。其次，对一个数完成了全部深度优先搜索后，比如对1完成了搜索，那么我们要把后面的1都跳过去。当然，跳过只是针对本轮搜索的，在对第一个1的下一轮的搜索中，我们还是可以加上第二个1。只是我们不能再以第二个1开头了而已。为了能连续跳过重复的数，这里我们必须先排序。

43.Multiply Strings 
```
public class multiply {
    public String multiply(String num1, String num2) {
        if (num1.equals("0")||num2.equals("0"))
            return "0";
        int[] n1=new int[num1.length()];
        int[] n2=new int[num2.length()];
        int[] n=new int[num1.length()+num2.length()];
        int j=0;
        for (int i=num1.length()-1;i>=0;i--){
            n1[j++]=(int)(num1.charAt(i)-'0');
        }
        j=0;
        for (int i=num2.length()-1;i>=0;i--){
            n2[j++]=(int)(num2.charAt(i)-'0');
        }
        //将相乘的结果保存，不考虑进位问题
        for(int i = 0; i < n1.length; i++){
            for(j = 0; j < n2.length; j++){
                //n一定是i+j，因为每次变动都要补一位0
                n[i+j] += n1[i]*n2[j];//不考虑进位，最后统一处理进位问题
            }
        }
        String result="";
        int k=0;//进位
        //处理进位问题
        for (int i=0;i<n.length;i++){
            n[i]=n[i]+k; //先加进位
            k=n[i]/10;//下一个进位
            n[i]=n[i]%10;//余数
            result=n[i]+result;//讲结果逆序保存
        }
        result=result.replaceAll("^0*","");//将开头的0去掉
        return result;
    }
}

```
46.Permutations

```
public class permute {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> lists=new LinkedList<>();
        List<Integer> temp=new LinkedList<>();
        search(nums,temp,lists);
        return lists;
    }
    private void search(int[] arrays,List<Integer> temp,List<List<Integer>> lists){
        if (temp.size()==arrays.length){
            if (!lists.contains(temp)){
                lists.add(new LinkedList<Integer>(temp));
                return;
            }
        }
        for (int i=0;i<arrays.length;i++){
            if (temp.contains(arrays[i]))continue;
            temp.add(arrays[i]);
            search(arrays,temp,lists);
            temp.remove(temp.size()-1);
        }
    }
}
```
47.Permutations II   

```
public class permuteUnique {
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> lists=new LinkedList<>();
        List<Integer> temp=new LinkedList<>();
        boolean[] visited=new boolean[nums.length];
        Arrays.sort(nums);
        search2(nums,temp,lists,visited);
        return lists;
    }
    private void search2(int[] arrays,List<Integer> temp,List<List<Integer>> lists,boolean[] visited){
        if (temp.size()==arrays.length){
            lists.add(new LinkedList<Integer>(temp));
            return;
        }
        for (int i=0;i<arrays.length;i++){
            //若是visited上一个元素是false并且跟上一个元素相等则跳过
            if (i>0&&arrays[i-1]==arrays[i]&&!visited[i-1])continue;
            //当visted为false时，退回到上一个轮回被标记为false，继续上一个轮回的下一个元素
            if (!visited[i]){
                temp.add(arrays[i]);
                visited[i]=true;
                search2(arrays,temp,lists,visited);
                temp.remove(temp.size()-1);
                visited[i]=false;
            }
        }
    }
}
```
思路：关键是去重，加上visited来判断，就可以做到
###### 参考：http://www.cnblogs.com/springfor/p/3898447.html
48.Rotate Image
```
public class rotate {
    public void rotate(int[][] matrix) {
        int n=matrix.length;
        int temp[][]=new int[n][n];
        for (int i=n-1;i>=0;i--){
            for (int j=0;j<n;j++){
                temp[j][n-1-i]=matrix[i][j];
            }
        }
        for (int i=0;i<n;i++){
            for (int j=0;j<n;j++){
                matrix[i][j]=temp[i][j];
            }
        }
        return;
    }
}

```
49. Group Anagrams

```
public class groupAnagrams {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> lists=new LinkedList<>();
        Map<String,List<String>> map=new HashMap<>();
        for (String s:strs){
            char[] chars=s.toCharArray();
            Arrays.sort(chars);
            //char类型转换为String类型
            String key=String.valueOf(chars);
            if (!map.containsKey(key))
                //因为map的value是List类型，所以遇到不一样的key就会新建一个新的List和key
                map.put(key,new LinkedList<>());
            //value添加到相同key的value中，value是List类型
            map.get(key).add(s);
        }
        //挨个读取key值
        for (String s:map.keySet()){
            //读取key的value值
            List<String> list=map.get(s);
            Collections.sort(list);
            lists.add(list);
        }
        return lists;
    }
}
```
50. Pow(x, n)

```
public class myPow {
    public double myPow(double x, int n) {
        if (x==0) return 0;
        if (n==0) return 1;
        x = n>0 ? x : 1/x;
        n = Math.abs(n);
        //当n为奇数时，调用递归
        if (n%2!=0)
            return x*myPow(x,n-1);
        double result=x;
        long temp=1;
        //result的结果为temp次幂
        while (n>=(temp+temp)){
            temp+=temp;
            result*=result;
        }
        //当temp大于n时，就需要递归再次运算
        return result*myPow(x,n-(int)temp);
    }
}
```





